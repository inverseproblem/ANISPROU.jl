<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>ANISPROU · ANISPROU</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>ANISPROU</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>ANISPROU</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#Installation"><span>Installation</span></a></li><li class="toplevel"><a class="tocitem" href="#Tutorial"><span>Tutorial</span></a></li><li><a class="tocitem" href="#Read-the-data"><span>Read the data</span></a></li><li><a class="tocitem" href="#setupip"><span>Setup the inverse problem: fitting the enthalpy data</span></a></li><li><a class="tocitem" href="#invprobsect"><span>Solve the inverse problem: find optimal mix of Beta functions</span></a></li><li><a class="tocitem" href="#Estimation-of-the-binding-isotherm"><span>Estimation of the binding isotherm</span></a></li><li><a class="tocitem" href="#Calculating-areas-and-volumes"><span>Calculating areas and volumes</span></a></li><li class="toplevel"><a class="tocitem" href="#Public-API"><span>Public API</span></a></li><li><a class="tocitem" href="#General-calculations"><span>General calculations</span></a></li><li><a class="tocitem" href="#Plotting"><span>Plotting</span></a></li><li class="toplevel"><a class="tocitem" href="#Other-non-exported-functions"><span>Other non-exported functions</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>ANISPROU</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>ANISPROU</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/inverseproblem/ANISPROU.jl/blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="ANISPROU"><a class="docs-heading-anchor" href="#ANISPROU">ANISPROU</a><a id="ANISPROU-1"></a><a class="docs-heading-anchor-permalink" href="#ANISPROU" title="Permalink"></a></h1><p>ANalysis of ISothermal titration calorimetry data on sodium dodecyl sulphate mediated PRotein Unfolding.</p><p>Analysis of isothermal titration calorimetry (ITC) data on sodium dodecyl sulphate (SDS) mediated protein unfolding (ANISPROU) is a tool developed to globally fit an entire dataset and to extract thermodynamic values from this fit. ITC data on SDS mediated protein unfolding, at different protein concentrations, is used as an input for the fitting. The linearity of the features in the ITC data as a function of protein concentration allows the data to be fitted using a number of 3D beta functions, each representing a thermodynamic event. Besides the enthalpy of unfolding, the binding isotherm is also among the outputs. </p><p>Contents:</p><ul><li><a href="#ANISPROU">ANISPROU</a></li><li><a href="#Installation">Installation</a></li><li><a href="#Tutorial">Tutorial</a></li><ul><li><a href="#Read-the-data">Read the data</a></li><li><a href="#setupip">Setup the inverse problem: fitting the enthalpy data</a></li><li><a href="#invprobsect">Solve the inverse problem: find optimal mix of Beta functions</a></li><li><a href="#Estimation-of-the-binding-isotherm">Estimation of the binding isotherm</a></li><li><a href="#Calculating-areas-and-volumes">Calculating areas and volumes</a></li></ul><li><a href="#Public-API">Public API</a></li><ul><li><a href="#General-calculations">General calculations</a></li><li><a href="#Plotting">Plotting</a></li></ul><li><a href="#Other-non-exported-functions">Other non-exported functions</a></li></ul><h1 id="Installation"><a class="docs-heading-anchor" href="#Installation">Installation</a><a id="Installation-1"></a><a class="docs-heading-anchor-permalink" href="#Installation" title="Permalink"></a></h1><p>To install the package simple enter into the package manager mode in Julia by typing &quot;<code>]</code>&quot; at the REPL prompt and then use <code>add</code>, i.e.,</p><pre><code class="language-julia hljs">(v1.6) pkg&gt; add ANISPROU</code></pre><p>The package will be automatically downloaded from the web and installed.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>At the moment the package is not yet registered in the official Julia registry, so,  to install it run the following in package mode:</p><pre><code class="language-julia hljs">(v1.6) pkg&gt; add https://github.com/inverseproblem/ANISPROU.jl</code></pre></div></div><h1 id="Tutorial"><a class="docs-heading-anchor" href="#Tutorial">Tutorial</a><a id="Tutorial-1"></a><a class="docs-heading-anchor-permalink" href="#Tutorial" title="Permalink"></a></h1><p>In the following a step-by-step tutorial illustrating how to process the ITC data is shown. The complete code is also available in the folder <code>examples</code>.</p><h2 id="Read-the-data"><a class="docs-heading-anchor" href="#Read-the-data">Read the data</a><a id="Read-the-data-1"></a><a class="docs-heading-anchor-permalink" href="#Read-the-data" title="Permalink"></a></h2><p>First of all, import the package and read the data. The function <a href="#ANISPROU.readallexperiments"><code>readallexperiments</code></a> takes care of reading the measred data from a ASCII/text file produced by some common instruments. </p><p>However, the user can read/obtain the data in any other way, as long as it is possible to create a structure <a href="#ANISPROU.ITCObsData"><code>ITCObsData</code></a>, which it is what is used in all the calculations (e.g., data fitting).</p><p>If using the <a href="#ANISPROU.readallexperiments"><code>readallexperiments</code></a> function, the directory containing the data set and the file names must have a certain structure in order for the function reading the data to work. Such structure should be like the following example, where the directory name is the protein name <code>IM7</code>:</p><pre><code class="nohighlight hljs">  050_IM7.DAT
  075_IM7.DAT
  100_IM7.DAT
  125_IM7.DAT
  150_IM7.DAT</code></pre><p>where the file names must follow the following rules:</p><ul><li>they must end with &quot;.DAT&quot; or &quot;.dat&quot;</li><li>they must contain the name of protein (e.g., &quot;IM7&quot;) in the file name</li><li>the file format must be the same than the provided example (a commonly used instrument).</li></ul><p>Two optional parameters can be passed to <a href="#ANISPROU.readallexperiments"><code>readallexperiments</code></a>, namely <code>scalfactor</code> (defaulting to 0.004184 to convert Cal/mol to kJ/mol) which scales the enthalpy values, and <code>discninitrows</code> (defaulting to 0) which skips a certain  number of initial rows from the data set because usually initial data are affected by strong instrument noise which could bias the subsequent fitting process.  See <a href="#ANISPROU.readallexperiments"><code>readallexperiments</code></a> to adapt it to a different case.</p><p>Next step is to extract the concentration of SDS and protein, the measured enthalpy and the indices for each experiments (<code>idxdata</code>) in the global data set. We obtain a dictionary, <code>data</code> in this case, containing all necessary information. </p><pre><code class="language-julia hljs">using ANISPROU

inpdir=&quot;../../examples/inputdata/&quot; # directory containing input data
protein = &quot;IM7&quot; # protein name
data = readallexperiments(inpdir,[protein])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Reading data from directory: ../../examples/inputdata/
 Scaling enthalpy values by a factor 0.004184
 Input file list:
  050_IM7.DAT
  075_IM7.DAT
  100_IM7.DAT
  125_IM7.DAT
  150_IM7.DAT</code></pre><p>Then instantiate the <code>ITCObsData</code> structure containing the measured (observed) enthalpy values along with other information. See <a href="#ANISPROU.ITCObsData"><code>ITCObsData</code></a>.</p><pre><code class="language-julia hljs">sdscon = data[protein][&quot;sdscon&quot;]
procon = data[protein][&quot;procon&quot;]
enthalpy = data[protein][&quot;enout&quot;]
idxdata = data[protein][&quot;idxdata&quot;]

dobs = ITCObsData(protein=protein,enthalpy=enthalpy,idxdata=idxdata,sdsprotcon=[sdscon procon])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ITCObsData([0.0, -0.05949610344, -1.6768066594400002, -2.6517443482400003, -3.4167277455200002, -3.32105058576, -2.86971330096, -2.4897795744, -2.4161389568800002, -2.3742685392  …  -2.60446799336, -2.59400506456, -2.01259926968, -1.24096193168, -0.68109080824, -0.40938289424, -0.25536362008, -0.10109786648, 0.034799081120000006, -0.04193489312], UnitRange{Int64}[1:39, 40:78, 79:117, 118:156, 157:195], [0.0 0.05; 0.24462 0.04976; … ; 16.49974 0.12504; 16.89997 0.12443], &quot;IM7&quot;)</code></pre><p>The <code>x</code> axis represents the SDS concentration, while the <code>y</code> axis the protein concentration. To plot the observed data one can use the function <a href="#ANISPROU.plotobsdata"><code>plotobsdata</code></a>:</p><pre><code class="language-julia hljs">plotobsdata(dobs)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">QStandardPaths: XDG_RUNTIME_DIR not set, defaulting to &#39;/tmp/runtime-runner&#39;</code></pre><p><img src="plotobsdata.svg" alt/> Another way of visualising the observed data is plotting each single experiment in 1D using <a href="#ANISPROU.plotsingleexperiments"><code>plotsingleexperiments</code></a>:</p><pre><code class="language-julia hljs">outdir=&quot;figs&quot;
plotsingleexperiments(outdir,dobs)</code></pre><p><img src="plotsingexpobs.svg" alt/></p><h2 id="setupip"><a class="docs-heading-anchor" href="#setupip">Setup the inverse problem: fitting the enthalpy data</a><a id="setupip-1"></a><a class="docs-heading-anchor-permalink" href="#setupip" title="Permalink"></a></h2><p>Now define the parameters of the 2D Beta functions: the type of function for the mode, concentration parameter and amplitude (e.g., linear), the <code>x</code> and <code>y</code> limits in terms of minimum and maximum of SDS and protein concentrations. See <a href="#ANISPROU.ScaledBeta2DParams"><code>ScaledBeta2DParams</code></a>. Often enlarging by a little bit the domain on the <code>x</code> axis helps the Beta functions to better fit the data.</p><pre><code class="language-julia hljs">a = 0.99*minimum(dobs.sdsprotcon[:,1]) # lower bound for beta domain
b = 1.05*maximum(dobs.sdsprotcon[:,1]) # upper bound for beta domain

minprotcon = minimum(dobs.sdsprotcon[:,2])
# setting the maximum SDS concentration higher than the maximum experimental value!
maxprotcon = 1.05*maximum(dobs.sdsprotcon[:,2])

## define the parameters of Beta 2D functions
modefuny = &quot;linear&quot;
konfuny  = &quot;linear&quot;
ampfuny  = &quot;linear&quot;
betpar = ScaledBeta2DParams(modefuny=modefuny,konfuny=konfuny,ampfuny=ampfuny,a=a,b=b,ymin=minprotcon,ymax=maxprotcon)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ScaledBeta2DParams(6, &quot;linear&quot;, &quot;linear&quot;, &quot;linear&quot;, 0.0, 17.7449685, 0.04148, 0.1575, 1, 3, 5)</code></pre><p>Now we need to define a so-called starting model, i.e., a set of parameters for the Beta functions (mode, concentration and amplitude) which constitutes our initial guess in order to fit the measured enthalpy data.</p><p>The starting model is represented by a 2D array where the number of rows is the number of Beta functions components. Each column contains the set of parameters necessary to define a  single Beta component, namely mode, confidence parameter and amplitude.  If we set the all the functions for mode, concentration and amplitude to be <em>linear</em> (see above), then the parameters of the Beta functions (mode, confidence and amplitude) will vary along <code>y</code> (protein concentration) following the equation of a straight line passing through two poins:</p><p class="math-container">\[ y = \dfrac{(y_2-y_1)}{(x_2-x_1)} (x-x_1) + y_1\]</p><p>where <span>$y_1$</span>, <span>$y_2$</span>, <span>$x_1$</span> and  <span>$x_2$</span> are given as explained in the following. <span>$x_1$</span> and  <span>$x_2$</span> represent the value of the Beta parameters at the minimum and maximum protein concentration <span>$y_1$</span> and <span>$y_2$</span> specified in the structure <a href="#ANISPROU.ScaledBeta2DParams"><code>ScaledBeta2DParams</code></a>, called <code>ymin</code> and <code>ymax</code>.  Then the elements of the column vector represent the following:</p><ul><li>elements 1 and 2: value of the mode at the two points where the protein concentration equals <code>betpar.ymin</code> <code>betpar.ymax</code>, part of the structure <a href="#ANISPROU.ScaledBeta2DParams"><code>ScaledBeta2DParams</code></a></li><li>elements 3 and 4: value of the confidence parameter at the two points where the protein concentration equals <code>betpar.ymin</code> <code>betpar.ymax</code>, part of the structure <a href="#ANISPROU.ScaledBeta2DParams"><code>ScaledBeta2DParams</code></a></li><li>elements 5 and 6: value of the mode at the two points where the protein concentration equals <code>betpar.ymin</code> <code>betpar.ymax</code>, part of the structure <a href="#ANISPROU.ScaledBeta2DParams"><code>ScaledBeta2DParams</code></a>.</li></ul><p>In the following we create a starting model use 4 Beta components. To add more (remove) components we can simple add more (remove) columns in mstart.</p><pre><code class="language-julia hljs"># Elements are: 2 for mode, 2 for the confidence parameter and
#   2 for the amplitude parameter
comp1 = [0.6,  1.5,  35.0, 30.0, -2.5,  -5.0 ]
comp2 = [1.7,  4.8,  60.0, 40.0, -1.6,  -4.0 ]
comp3 = [4.5,  10.0, 40.0, 30.0, 0.12, 0.16 ]
comp4 = [6.2,  15.3, 60.0, 40.0, -1.6, -2.0 ]

# mstart is a 2D array where each column represents one component
mstart = [comp1 comp2 comp3 comp4]</code></pre><p>To visually check the goodness of our first guess we can plot it using</p><pre><code class="language-julia hljs">plotinitialguess(betpar,dobs,mstart)</code></pre><p><img src="plotinitguess.svg" alt/></p><h2 id="invprobsect"><a class="docs-heading-anchor" href="#invprobsect">Solve the inverse problem: find optimal mix of Beta functions</a><a id="invprobsect-1"></a><a class="docs-heading-anchor-permalink" href="#invprobsect" title="Permalink"></a></h2><p>The solution of the inverse problem, that is, finding the set of model parameters which produces a &quot;best&quot; fit to the observed data is based on a constrained Newton method. The Newton method requires the computation of both the gradient of the misfit function with respect to model parameters and the Hessian matrix. Both gradient and Hessian matrix are calculated using automatic differentiation, specifically using the &quot;forward mode&quot; approach provided by the <a href="https://github.com/JuliaDiff/ForwardDiff.jl"><code>ForwardDiff.jl</code></a> package.</p><p>First, we need to set the constraints for the Newton optimization. That can be done by specifying the lower and upper bounds for each parameter of each single component as following:</p><pre><code class="language-julia hljs"># lower constraints [confidence must be &gt;2.0]
lcs1 = [betpar.a, betpar.a, 2.1, 2.1, -20.0, -20.0]
lcs2 = [betpar.a, betpar.a, 2.1, 2.1, -20.0, -20.0]
lcs3 = [betpar.a, betpar.a, 2.1, 2.1,   0.0,   0.0]
lcs4 = [betpar.a, betpar.a, 2.1, 2.1, -20.0, -20.0]
lowconstr = [lcs1 lcs2 lcs3 lcs4]

# upper constraints
ucs1 = [betpar.b, betpar.b, 500.0, 500.0,  0.0,  0.0]
ucs2 = [betpar.b, betpar.b, 500.0, 500.0,  0.0,  0.0]
ucs3 = [betpar.b, betpar.b, 500.0, 500.0, 10.0, 10.0]
ucs4 = [betpar.b, betpar.b, 500.0, 500.0,  0.0,  0.0]
upconstr = [ucs1 ucs2 ucs3 ucs4]</code></pre><p>In order to solve the inverse problem we need a covariance matrix (symmetric positive-definite) representing the uncertainty on the observed data. What is actually required by the software is the inverse of such covariance matrix <code>invCd</code>, i.e., if <span>$\mathbf{C}_D$</span> is the covariance matrix on the observations, representing the noise on the data, we need to input the code <span>$\mathbf{C}^{-1}_D$</span>, sometimes called the precision matrix. Fine tuning the covariance/precision matrix for specific observed data known to be highly uncertain (or simply wrong) may <em>significantly help</em> the inversion process. </p><pre><code class="language-julia hljs">using LinearAlgebra
nobs = length(dobs.enthalpy)
stdobs = 0.2 .* ones(nobs) # standard deviation of the error on measured data
stdobs[1:2] .= 0.8 # specify higher uncertainty for first two points
stdobs[end-5:end] .= 0.5
invCd = inv(diagm(stdobs.^2)) # in this case a diagonal precision matrix</code></pre><p>Now we can run the Newton optimization algorithm to solve the inverse problem, provided also a starting model as explained in the previous <a href="#setupip"><code>section</code></a>. The algorithm is from the package <a href="https://github.com/JuliaNLSolvers/Optim.jl"><code>Optim.jl</code></a>, specifically it is an interior-point primal-dual Newton algorithm <a href="https://julianlsolvers.github.io/Optim.jl/stable/#algo/ipnewton/"></a>. The optization is launched by the following code, where <code>outdir</code> is the directory where the output results will be written. </p><pre><code class="language-julia hljs">outdir = &quot;output&quot;
betamix = solveinvprob(betpar,dobs,invCd,mstart,lowconstr,upconstr,outdir)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">
Running optimization with IPNewton...

 * Status: success

 * Candidate solution
    Final objective value:     1.809125e+02

 * Found with
    Algorithm:     Interior Point Newton

 * Convergence measures
    |x - x&#39;|               = 0.00e+00 ≤ 0.0e+00
    |x - x&#39;|/|x&#39;|          = 0.00e+00 ≤ 0.0e+00
    |f(x) - f(x&#39;)|         = 0.00e+00 ≤ 0.0e+00
    |f(x) - f(x&#39;)|/|f(x&#39;)| = 0.00e+00 ≤ 0.0e+00
    |g(x)|                 = 2.57e-06 ≰ 1.0e-08

 * Work counters
    Seconds run:   10  (vs limit Inf)
    Iterations:    39
    f(x) calls:    123
    ∇f(x) calls:   123

Saving results in JLD2 to output/IM7_ITCinvresults.jld2
Saving results in text file to output/IM7_ITCinvresults.dat</code></pre><p>The output <code>betamix</code> is a structure of type <a href="#ANISPROU.BetaMix2D"><code>BetaMix2D</code></a> which holds the optimized parameters and other additional information. The results are saved in the directory defined by the variable <code>output</code> both in the HDF5 format, including all parameters of the inversion and as a simple set of text files (.dat).</p><h4 id="Additional-nonlinear-constraints"><a class="docs-heading-anchor" href="#Additional-nonlinear-constraints">Additional nonlinear constraints</a><a id="Additional-nonlinear-constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Additional-nonlinear-constraints" title="Permalink"></a></h4><p>The function <a href="#ANISPROU.solveinvprob"><code>solveinvprob</code></a> accepts an <strong>additional optional parameter</strong> <code>applynonlinconstr</code> which, when set to <code>true</code> adds a set of nonlinear constraints to the Newton optimization. These constraints are a zero (or minimum) area for each Beta component at protein concentration equal to zero and some other constraints on the modes and confidence parameters requiring the solution to have modes within bound at protein concentration equal to zero and an increasing confidence parameter for decreasing protein concentration. The optional positive parameter <code>constrarea</code> defines (when <code>applynonlinconstr=true</code>) a constraint for the area of sum of the mix of Beta function at protein concentration equal to zero.</p><pre><code class="language-julia hljs">betamix = solveinvprob(betpar,dobs,invCd,mstart,lowconstr,upconstr,outdir,applynonlinconstr=true,constrarea=6.0)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">
Running optimization with IPNewton...

 * Status: success

 * Candidate solution
    Final objective value:     1.905817e+02

 * Found with
    Algorithm:     Interior Point Newton

 * Convergence measures
    |x - x&#39;|               = 0.00e+00 ≤ 0.0e+00
    |x - x&#39;|/|x&#39;|          = 0.00e+00 ≤ 0.0e+00
    |f(x) - f(x&#39;)|         = 0.00e+00 ≤ 0.0e+00
    |f(x) - f(x&#39;)|/|f(x&#39;)| = 0.00e+00 ≤ 0.0e+00
    |g(x)|                 = 1.81e+01 ≰ 1.0e-08

 * Work counters
    Seconds run:   21  (vs limit Inf)
    Iterations:    50
    f(x) calls:    121
    ∇f(x) calls:   121

Saving results in JLD2 to output/IM7_ITCinvresults.jld2
Saving results in text file to output/IM7_ITCinvresults.dat</code></pre><h3 id="Plotting-results"><a class="docs-heading-anchor" href="#Plotting-results">Plotting results</a><a id="Plotting-results-1"></a><a class="docs-heading-anchor-permalink" href="#Plotting-results" title="Permalink"></a></h3><p>Finally, it is possible to visualize the results as following:</p><pre><code class="language-julia hljs">outdir = &quot;figs&quot;
plotresults(betamix,dobs,mstart,outdir)</code></pre><p><img src="figs/IM7_results.svg" alt/></p><p>The function <a href="#ANISPROU.plotsingleexperiments"><code>plotsingleexperiments</code></a> provides a way to show the fit of the solution to the single experiments, i.e., enthalpy for different initial protein concentrations. </p><pre><code class="language-julia hljs"># plot fit to single experiments
outdir=&quot;figs&quot;
plotsingleexperiments(outdir,dobs,betamix)</code></pre><p><img src="figs/IM7_experiment1.svg" alt/> Another plot is that of parameter values versus protein concentration, where the black lines represent the bounds derived from the experimental data:</p><pre><code class="language-julia hljs">plotparamlines(betamix)</code></pre><p><img src="figs/IM7_paramlines.svg" alt/> It&#39;s also possible to plot Beta function components and their sum for fixed protein concentration, e.g.:</p><pre><code class="language-julia hljs">plotbetacomp1D(betamix,0.148)</code></pre><p><img src="plotsingcomp.svg" alt/></p><h4 id="Plot-the-3D-surface-vs.-observed-data"><a class="docs-heading-anchor" href="#Plot-the-3D-surface-vs.-observed-data">Plot the 3D surface vs. observed data</a><a id="Plot-the-3D-surface-vs.-observed-data-1"></a><a class="docs-heading-anchor-permalink" href="#Plot-the-3D-surface-vs.-observed-data" title="Permalink"></a></h4><p>It is possible to make a 3D plot showing the surface defined by the Beta mix and, in addition, the set of observed data as circles.</p><pre><code class="language-julia hljs">plotsurface3D(dobs,betamix,markersize=3500,savefig=true,outdir=&quot;figs&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">
Plotting 3D surface from Beta mix and measured data as circles.
 Scaling factors are 100.0 for [IM7] and 2.0 for enthalpy.
[ Info: Makie/Makie is caching fonts, this may take a while. Needed only on first run!</code></pre><p><img src="figs/surfaceplot.png" alt/></p><h2 id="Estimation-of-the-binding-isotherm"><a class="docs-heading-anchor" href="#Estimation-of-the-binding-isotherm">Estimation of the binding isotherm</a><a id="Estimation-of-the-binding-isotherm-1"></a><a class="docs-heading-anchor-permalink" href="#Estimation-of-the-binding-isotherm" title="Permalink"></a></h2><p>The binding isotherm can be estimated by defining a set of points or &quot;features&quot; on the 2D Beta functions such that given features for a certain protein concentration can be related to corresponding features at different protein concentrations. Such features could be, for instance, the peaks of the curves or their inflection points. A set of the same feature for different protein concentrations should produce a trend close to a straight line, which can be used to estimate the binding isotherm. The angular coefficient of such straight line will then represent the binding number <span>$N_{\rm bound}$</span> and the intercept the concentration of free SDS <span>$[SDS]_{\rm free}$</span>. The two are in fact related by the following relation:</p><p class="math-container">\[ [\mathrm{SDS}]_{\rm total} =  [\mathrm{SDS}]_{\rm free} + N_{\rm bound} [\mathrm{Protein}]\]</p><p>where <span>$[...]$</span> represents the concentration.</p><p>Thus, to estimate the binding isotherm, we start by finding a set of features, in this case stationary and inflection points at given values of protein concentration (in this case 4 values):</p><pre><code class="language-julia hljs">ny = 4 # number of protein concentrations to investigate
protcon = collect(LinRange(betamix.betpar.ymin,betamix.betpar.ymax,ny)) # set of protein concentrations
statpts,inflpts = findcurvefeatures(betamix,protcon) # find features</code></pre><p>To plot the found features one can do the following:</p><pre><code class="language-julia hljs"># plot found points/features
outdir = &quot;figs&quot;
plotfoundfeatures(betamix,protcon,statpts,inflpts,outdir)</code></pre><p><img src="plotfeat.svg" alt/></p><p>The next step involves selecting a subset of the found points to construct the binding isotherm: this can be done by looking at the previous plot and picking only desired points. The numbers on the plot nearby the found points correspond to the index in the array of found points.</p><pre><code class="language-julia hljs"># ===========================================
# Selection of local minima and maxima
selectstatpts = Vector{Array{&lt;:Real,2}}(undef,0)

push!(selectstatpts, [ statpts[1][2] protcon[1];
                       statpts[2][2] protcon[2];
                       statpts[3][2] protcon[3];
                       statpts[4][2] protcon[4] ] )

push!(selectstatpts, [ statpts[2][3] protcon[2];
                       statpts[3][3] protcon[3];
                       statpts[4][3] protcon[4] ] )

push!(selectstatpts, [ statpts[1][3] protcon[1];
                       statpts[2][5] protcon[2];
                       statpts[3][5] protcon[3];
                       statpts[4][5] protcon[4] ] )

push!(selectstatpts, [ statpts[1][4] protcon[1];
                       statpts[2][6] protcon[2];
                       statpts[3][6] protcon[3];
                       statpts[4][6] protcon[4] ] )

# ===========================================
# Selection of inflection points
selectinflpts = Vector{Array{&lt;:Real,2}}(undef,0)

push!(selectinflpts, [ inflpts[1][1] protcon[1];
                       inflpts[2][2] protcon[2];
                       inflpts[3][2] protcon[3];
                       inflpts[4][2] protcon[4] ] )

push!(selectinflpts, [ inflpts[1][2] protcon[1];
                       inflpts[2][3] protcon[2];
                       inflpts[3][3] protcon[3];
                       inflpts[4][3] protcon[4] ] )

push!(selectinflpts, [ inflpts[1][4] protcon[1];
                       inflpts[2][5] protcon[2];
                       inflpts[3][5] protcon[3];
                       inflpts[4][5] protcon[4] ] )</code></pre><p>Once we have a set of set of features we can estimate the best fitting straight lines for each set by performing a least squares linear regression with <a href="#ANISPROU.calcfreeSDSNbound"><code>calcfreeSDSNbound</code></a>. </p><pre><code class="language-julia hljs"># find the straight line by least squares
freeSDS,Nbound,resstdev = calcfreeSDSNbound(protcon,statpts,inflpts,selectstatpts,selectinflpts,outdir,dobs.protein) # do the linear regression</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Saving binding isotherm data in JL2 to figs/IM7_ITCbindingisoth.jld2

Saving results in text file to figs/IM7_ITCbindingisoth.dat</code></pre><p><code>resstedev</code> is a vector containing the standard deviation of the residuals of the regression for each point of the binding isotherm.</p><p>Finally, the resulting binding isotherm is plotted with the following:</p><pre><code class="language-julia hljs">outdir = &quot;figs&quot;
plotbindisotherm(betamix,protcon,dobs,statpts,inflpts,freeSDS,Nbound,outdir,resstdev=resstdev)</code></pre><p><img src="plotbindisoth.svg" alt/></p><h2 id="Calculating-areas-and-volumes"><a class="docs-heading-anchor" href="#Calculating-areas-and-volumes">Calculating areas and volumes</a><a id="Calculating-areas-and-volumes-1"></a><a class="docs-heading-anchor-permalink" href="#Calculating-areas-and-volumes" title="Permalink"></a></h2><p>Compute the area for each Beta component at requested protein concentration using <a href="#ANISPROU.area_enthalpy"><code>area_enthalpy</code></a>:</p><pre><code class="language-julia hljs">protcon = 0.08 # requested protein concentration
area,errarea = area_enthalpy(betamix,protcon) # compute area
println(&quot;Area at protein concentration $protcon for each component: \n$area, \nintegration error\n $errarea\n&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Area at protein concentration 0.08 for each component:
[-7.281750276625282e-7, -2.9209969955488645e-6, 6.732398847454579e-7, -6.849130051866971e-7],
integration error
 [2.1403273431041072e-15, 2.0275296638666627e-14, 8.37933219790935e-17, 1.2316369315042954e-15]</code></pre><p>It is also possible to calculate the area for each Beta component for a set of different protein concentrations and plot it using <a href="#ANISPROU.areasvsprotcon"><code>areasvsprotcon</code></a> and <a href="#ANISPROU.plotareavsprotcon"><code>plotareavsprotcon</code></a>:</p><pre><code class="language-julia hljs">N = 15
protcons = collect(LinRange(0.0,0.14,N)) # set of protein concentrations
areas,erras,linfitres,resstdev = areasvsprotcon(betamix,protcons,outdir,protein)
plotareavsprotcon(protein,protcons,areas,linfitres,resstdev,outdir) # plot area as a function of protein concentration</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Saving areas data in JLD2 to figs/IM7_ITCareasprotcon.jld2

### Protein IM7, area vs. protein conc. ###
Linear fit, Beta comp. #1, ang.coef.=-9.91389647110213e-6,
                           intecept=-1.7827713007291905e-8
Linear fit, Beta comp. #2, ang.coef.=-3.309414178152313e-5,
                           intecept=-4.3535599659236787e-7
Linear fit, Beta comp. #3, ang.coef.=9.350888784357902e-6,
                           intecept=1.9053520863971686e-8
Linear fit, Beta comp. #4, ang.coef.=-7.799798863794685e-6,
                           intecept=-1.32188791414875e-7</code></pre><p><img src="plotsetareas.svg" alt/></p><p>Alternatively, a function to plot the value of model parameters and areas as a function of protein concentration is available, <a href="#ANISPROU.plotparamlines"><code>plotparamlines</code></a></p><pre><code class="language-julia hljs">plotparamlines(betamix,protcons,areas)</code></pre><p><img src="plotareasparlines.svg" alt/></p><p>Compute the volume for all Beta components within requested bounds of protein concentration using <a href="#ANISPROU.volume_enthalpy"><code>volume_enthalpy</code></a>:</p><pre><code class="language-julia hljs">minprotcon = betamix.betpar.ymin  # lower bound for integral
maxprotcon = betamix.betpar.ymax  # upper bound for integral
volume,errvol = volume_enthalpy(betamix,minprotcon,maxprotcon) # compute volume
println(&quot;Volume within bounds for each component: \n$volume, \nintegration error\n $errvol\n&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Volume within bounds for each component:
[-1.1789989095598014e-7, -4.3417254497699103e-7, 1.1292077784420347e-7, -1.1166190040188133e-7],
integration error
 [1.173617553170881e-15, 4.340670353466813e-15, 1.1281608712826411e-15, 1.1164456064654547e-15]</code></pre><h1 id="Public-API"><a class="docs-heading-anchor" href="#Public-API">Public API</a><a id="Public-API-1"></a><a class="docs-heading-anchor-permalink" href="#Public-API" title="Permalink"></a></h1><h2 id="General-calculations"><a class="docs-heading-anchor" href="#General-calculations">General calculations</a><a id="General-calculations-1"></a><a class="docs-heading-anchor-permalink" href="#General-calculations" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ANISPROU" href="#ANISPROU"><code>ANISPROU</code></a> — <span class="docstring-category">Module</span></header><section><div><p>ANISPROU</p><p>Analysis of isothermal titration calorimetry (ITC) data on sodium dodecyl sulphate (SDS) mediated protein unfolding.</p><p><strong>Exports</strong></p><ul><li><a href="#ANISPROU.BetaMix2D"><code>BetaMix2D</code></a></li><li><a href="#ANISPROU.ITCObsData"><code>ITCObsData</code></a></li><li><a href="#ANISPROU.ScaledBeta2DParams"><code>ScaledBeta2DParams</code></a></li><li><a href="#ANISPROU.area_enthalpy"><code>area_enthalpy</code></a></li><li><a href="#ANISPROU.areasvsprotcon"><code>areasvsprotcon</code></a></li><li><a href="#ANISPROU.calcfreeSDSNbound"><code>calcfreeSDSNbound</code></a></li><li><a href="#ANISPROU.findcurvefeatures"><code>findcurvefeatures</code></a></li><li><a href="#ANISPROU.plotareavsprotcon"><code>plotareavsprotcon</code></a></li><li><a href="#ANISPROU.plotbetacomp1D"><code>plotbetacomp1D</code></a></li><li><a href="#ANISPROU.plotbindisotherm"><code>plotbindisotherm</code></a></li><li><a href="#ANISPROU.plotfoundfeatures"><code>plotfoundfeatures</code></a></li><li><a href="#ANISPROU.plotinitialguess"><code>plotinitialguess</code></a></li><li><a href="#ANISPROU.plotobsdata"><code>plotobsdata</code></a></li><li><a href="#ANISPROU.plotparamlines"><code>plotparamlines</code></a></li><li><a href="#ANISPROU.plotresults"><code>plotresults</code></a></li><li><a href="#ANISPROU.plotsingleexperiments"><code>plotsingleexperiments</code></a></li><li><a href="#ANISPROU.plotsurface3D"><code>plotsurface3D</code></a></li><li><a href="#ANISPROU.readallexperiments"><code>readallexperiments</code></a></li><li><a href="#ANISPROU.saveresultVTK"><code>saveresultVTK</code></a></li><li><a href="#ANISPROU.solveinvprob"><code>solveinvprob</code></a></li><li><a href="#ANISPROU.volume_enthalpy"><code>volume_enthalpy</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inverseproblem/ANISPROU.jl/blob/17af90c1ac45d3341b79a786a8a91481521c4a13/src/ANISPROU.jl#L7-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ANISPROU.readallexperiments" href="#ANISPROU.readallexperiments"><code>ANISPROU.readallexperiments</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">readallexperiments(inpdir::String, proteinnames::Vector{String}; scalfactor, discninitrows) -&gt; Dict{Any, Any}
</code></pre><p>Real from ASCII files all observed/measured data from a set of experiments. It can read data for one or more proteins. The entalphy values are <em>scaled</em> by a factor given by the argument <code>scalfactor</code>,   which defaults to 0.004184 (Cal/mol to kJ/mol).</p><p><strong>Arguments</strong></p><ul><li><code>inpdir</code>: directory containing the input data</li><li><code>proteinnames</code>: array of strings containing the names of proteins</li><li><code>scalfactor</code>=0.004184: scaling factor for enthalpy, defaults                        to 0.004184 (Cal/mol to kJ/mol)</li><li><code>discninitrows</code>=0: number of initial rows of the data set to discard. This is used                   to remove some initial data often affected by strong                    instrument noise which could bias the fitting process.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inverseproblem/ANISPROU.jl/blob/17af90c1ac45d3341b79a786a8a91481521c4a13/src/readITCdata.jl#L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ANISPROU.ITCObsData" href="#ANISPROU.ITCObsData"><code>ANISPROU.ITCObsData</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ITCObsData</code></pre><p>Structure containing the observed (measured) data, i.e. the enthalpy, the protein and SDS concentration.</p><p><strong>Fields</strong></p><ul><li><p><code>enthalpy::Vector{var&quot;#s9&quot;} where var&quot;#s9&quot;&lt;:Real</code></p><p>Enthalpy values</p></li><li><p><code>idxdata::Vector{UnitRange{Int64}}</code></p><p>Indices pointing to single experiments data</p></li><li><p><code>sdsprotcon::Matrix{var&quot;#s8&quot;} where var&quot;#s8&quot;&lt;:Real</code></p><p>Concentration of SDS (first column) and protein (second column)</p></li><li><p><code>protein::String</code></p><p>Name of the protein</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inverseproblem/ANISPROU.jl/blob/17af90c1ac45d3341b79a786a8a91481521c4a13/src/invertITCdata2D.jl#L78">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ANISPROU.ScaledBeta2DParams" href="#ANISPROU.ScaledBeta2DParams"><code>ANISPROU.ScaledBeta2DParams</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ScaledBeta2DParams</code></pre><p>Structure containing the parameters of the 2D Beta functions.</p><p><strong>Fields</strong></p><ul><li><p><code>nummodpar::Integer</code></p><p>number of model parameters</p></li><li><p><code>modefuny::String</code></p><p>type of function on y (protein concentration) for the mode</p></li><li><p><code>konfuny::String</code></p><p>type of function on y (protein concentration) for the confidence parameter</p></li><li><p><code>ampfuny::String</code></p><p>type of function on y (protein concentration) for the amplitude</p></li><li><p><code>a::Real</code></p><p>lower bound for Beta function (along x, i.e. SDS concentration)</p></li><li><p><code>b::Real</code></p><p>upper bound for Beta function (along y, i.e. protein concentration)</p></li><li><p><code>ymin::Real</code></p><p>user defined minimum y (protein concentration)</p></li><li><p><code>ymax::Real</code></p><p>user defined maximum y (protein concentration)</p></li><li><p><code>idxmode::Integer</code></p><p>starting index in the vector of model parameters for mode</p></li><li><p><code>idxkon::Integer</code></p><p>starting index in the vector of model parameters for confidence parameter</p></li><li><p><code>idxamp::Integer</code></p><p>starting index in the vector of model parameters for amplitude parameter</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inverseproblem/ANISPROU.jl/blob/17af90c1ac45d3341b79a786a8a91481521c4a13/src/invertITCdata2D.jl#L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ANISPROU.BetaMix2D" href="#ANISPROU.BetaMix2D"><code>ANISPROU.BetaMix2D</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct BetaMix2D</code></pre><p>Structure containing the observed (measured) data, i.e. the enthalpy, the protein and SDS concentration.</p><p><strong>Fields</strong></p><ul><li><p><code>betpar::ScaledBeta2DParams</code></p><p>structure containing the parameters of the 2D Beta functions</p></li><li><p><code>modkonamp::Matrix{var&quot;#s13&quot;} where var&quot;#s13&quot;&lt;:Real</code></p><p>2D array where each column is a set of mode, confidence and amplitude parameters</p></li><li><p><code>protein::String</code></p><p>name of the protein</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inverseproblem/ANISPROU.jl/blob/17af90c1ac45d3341b79a786a8a91481521c4a13/src/invertITCdata2D.jl#L101">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ANISPROU.solveinvprob" href="#ANISPROU.solveinvprob"><code>ANISPROU.solveinvprob</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">solveinvprob(betpar::ScaledBeta2DParams, dobs::ITCObsData, invCd::Matrix{var&quot;#s89&quot;} where var&quot;#s89&quot;&lt;:Real, mstart::Matrix{var&quot;#s90&quot;} where var&quot;#s90&quot;&lt;:Real, lowconstr::Matrix{var&quot;#s91&quot;} where var&quot;#s91&quot;&lt;:Real, upconstr::Matrix{var&quot;#s92&quot;} where var&quot;#s92&quot;&lt;:Real, outdir::String; applynonlinconstr, constrarea) -&gt; BetaMix2D
</code></pre><p>Solve the inverse problem, i.e., fit the measured enthalpy data,    using an Interior Point Newton method from the Optim.jl package.</p><p><strong>Arguments</strong></p><ul><li><code>betpar</code>: a struct containing the parameters for the Beta functions           See <a href="#ANISPROU.ScaledBeta2DParams"><code>ScaledBeta2DParams</code></a></li><li><code>dobs</code>: a struct containing the observed (measured) data and concentrations           See <a href="#ANISPROU.ITCObsData"><code>ITCObsData</code></a></li><li><code>invCd</code>: inverse of the covariance matrix on observations (precision matrix)</li><li><code>mstart</code>: the starting model</li><li><code>lowconstr</code>: array of lower constraints for all parameters</li><li><code>upconstr</code>: array of upper constraints for all parameters</li><li><code>outdir</code>: output directory to save results</li><li><code>applynonlinconstr</code>=false: optional parameter determining whether to use or                             not the nonlinear constraints</li><li><code>constrarea</code>=Inf: a positive real number defining the upper constraint for the value of area (enthalpy) at protein concentration equal to zero</li></ul><p><strong>Returns</strong></p><p>A structure holding Beta parameters and the solution in terms of mode, confidence parameter and amplitude. It also saves all the setup of the problem and a set of parameters to an HDF5 file. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inverseproblem/ANISPROU.jl/blob/17af90c1ac45d3341b79a786a8a91481521c4a13/src/invertITCdata2D.jl#L421">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ANISPROU.findcurvefeatures" href="#ANISPROU.findcurvefeatures"><code>ANISPROU.findcurvefeatures</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">findcurvefeatures(betamix::BetaMix2D, protcon::Vector{var&quot;#s92&quot;} where var&quot;#s92&quot;&lt;:Real) -&gt; Tuple{Vector{Vector{Float64}}, Vector{Vector{Float64}}}
</code></pre><p>Define a set of features on the Beta mix to subsequently compute the binding isotherm. It uses the stationary and inflection points at given protein concentrations (protcon). </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inverseproblem/ANISPROU.jl/blob/17af90c1ac45d3341b79a786a8a91481521c4a13/src/bindingisotherm.jl#L112">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ANISPROU.calcfreeSDSNbound" href="#ANISPROU.calcfreeSDSNbound"><code>ANISPROU.calcfreeSDSNbound</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">calcfreeSDSNbound(protcons::Vector{var&quot;#s87&quot;} where var&quot;#s87&quot;&lt;:Real, statpts::Array{Vector{Float64}, N} where N, inflpts::Array{Vector{Float64}, N} where N, selectstatpts::Vector{var&quot;#s86&quot;} where var&quot;#s86&quot;&lt;:(Matrix{var&quot;#s85&quot;} where var&quot;#s85&quot;&lt;:Real), selectinflpts::Vector{var&quot;#s84&quot;} where var&quot;#s84&quot;&lt;:(Matrix{var&quot;#s83&quot;} where var&quot;#s83&quot;&lt;:Real), outdir::String, protein::String) -&gt; Tuple{Any, Any, Any}
</code></pre><p>Calculate the concentration of free SDS (freeSDS) and binding number (NBound).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inverseproblem/ANISPROU.jl/blob/17af90c1ac45d3341b79a786a8a91481521c4a13/src/bindingisotherm.jl#L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ANISPROU.area_enthalpy" href="#ANISPROU.area_enthalpy"><code>ANISPROU.area_enthalpy</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">area_enthalpy(betamix::BetaMix2D, protcon::Real; volumescal) -&gt; Tuple{Vector{Float64}, Vector{Float64}}
</code></pre><p>Calculate the area of each individual Beta function for a given protein concentration.  The SDS concentration axis needs a unit conversion which is handled by the <code>volumescal</code>  arguments.</p><p><strong>Arguments</strong></p><ul><li><code>betamix</code>: structure of type <code>BetaMix2D</code> containing the parameters of the Beta functions,            the modes, confidence parameters and amplitudes and protein name</li><li><code>protcon</code>: protein concentration value (y axis) at which to perform the calculation of the area</li><li><code>volumescal</code>: scaling factor in μl to convert from mM to mole, instrument dependent. The default               is 203.0μl.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inverseproblem/ANISPROU.jl/blob/17af90c1ac45d3341b79a786a8a91481521c4a13/src/betaintegrals.jl#L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ANISPROU.areasvsprotcon" href="#ANISPROU.areasvsprotcon"><code>ANISPROU.areasvsprotcon</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">areasvsprotcon(betamix::BetaMix2D, protcons::Vector{Float64}, outdir::String, protein::String; volumescal) -&gt; Tuple{Matrix{Float64}, Matrix{Float64}, Matrix{Float64}, Vector{Float64}}
</code></pre><p>Calculate the area of each individual Beta function for a set of  protein concentrations.</p><p><strong>Arguments</strong></p><ul><li><code>betamix</code>: structure of type <code>BetaMix2D</code> containing the parameters of the Beta functions,            the modes, confidence parameters and amplitudes and protein name</li><li><code>protcosn</code>: array of protein concentrations at which to calculate the areas</li><li><code>volumescal</code>: scaling factor in μl to convert from mM to mole, instrument dependent. The default               is 203.0μl.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inverseproblem/ANISPROU.jl/blob/17af90c1ac45d3341b79a786a8a91481521c4a13/src/betaintegrals.jl#L79">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ANISPROU.volume_enthalpy" href="#ANISPROU.volume_enthalpy"><code>ANISPROU.volume_enthalpy</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">volume_enthalpy(betamix::BetaMix2D, minprotcon::Real, maxprotcon::Real; volumescal) -&gt; Tuple{Vector{Float64}, Vector{Float64}}
</code></pre><p>Calculate the volume of each single Beta function within given bounds of protein concentration. The SDS concentration axis needs a unit conversion which is handled by the <code>volumescal</code>  arguments.</p><p><strong>Arguments</strong></p><ul><li><code>betamix</code>: structure of type <code>BetaMix2D</code> containing the parameters of the Beta functions,            the modes, confidence parameters and amplitudes and protein name</li><li><code>minprotcon</code>: lower bound of protein concentration value (y axis) to perform the integral</li><li><code>maxprotcon</code>: upper bound of protein concentration value (y axis) to perform the integral</li><li><code>volumescal</code>=203.0: scaling factor in μl to convert from mM to mole, instrument dependent. The default               is 203.0μl.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inverseproblem/ANISPROU.jl/blob/17af90c1ac45d3341b79a786a8a91481521c4a13/src/betaintegrals.jl#L143">source</a></section></article><h2 id="Plotting"><a class="docs-heading-anchor" href="#Plotting">Plotting</a><a id="Plotting-1"></a><a class="docs-heading-anchor-permalink" href="#Plotting" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ANISPROU.plotobsdata" href="#ANISPROU.plotobsdata"><code>ANISPROU.plotobsdata</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">plotobsdata(dobs)
</code></pre><p>Plot the observed data as a scatter plot.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inverseproblem/ANISPROU.jl/blob/17af90c1ac45d3341b79a786a8a91481521c4a13/src/plotstuff.jl#L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ANISPROU.plotinitialguess" href="#ANISPROU.plotinitialguess"><code>ANISPROU.plotinitialguess</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">plotinitialguess(betpar, dobs, mstart)
</code></pre><p>Plot the fit to the enthalpy data as a result of the initial guess, i.e., the starting model parameters of the Beta functions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inverseproblem/ANISPROU.jl/blob/17af90c1ac45d3341b79a786a8a91481521c4a13/src/plotstuff.jl#L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ANISPROU.plotresults" href="#ANISPROU.plotresults"><code>ANISPROU.plotresults</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">plotresults(betamix, dobs, mstart, outdir)
</code></pre><p>Plot the results of inverting the ITC data to fit the enthalpy function in 2D.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inverseproblem/ANISPROU.jl/blob/17af90c1ac45d3341b79a786a8a91481521c4a13/src/plotstuff.jl#L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ANISPROU.plotsingleexperiments" href="#ANISPROU.plotsingleexperiments"><code>ANISPROU.plotsingleexperiments</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">plotsingleexperiments(outdir, dobs)
plotsingleexperiments(outdir, dobs, betamix)
</code></pre><p>Plot each single experiment, i.e., enthalpy for an initial protein concentration and increasing SDS concentration. If the third argument <code>betamix</code> is passed, shows a comparison of measured and calculate data (from results of inversion) including each single Beta component.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inverseproblem/ANISPROU.jl/blob/17af90c1ac45d3341b79a786a8a91481521c4a13/src/plotstuff.jl#L523">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ANISPROU.plotfoundfeatures" href="#ANISPROU.plotfoundfeatures"><code>ANISPROU.plotfoundfeatures</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">plotfoundfeatures(betamix, protcon, statpts, inflpts, outdir)
</code></pre><p>Plot the points/features defined on the enthalpy curves to find the binding isotherm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inverseproblem/ANISPROU.jl/blob/17af90c1ac45d3341b79a786a8a91481521c4a13/src/plotstuff.jl#L470">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ANISPROU.plotbindisotherm" href="#ANISPROU.plotbindisotherm"><code>ANISPROU.plotbindisotherm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">plotbindisotherm(betamix, protcon, dobs, statpts, inflpts, freeSDS, Nbound, outdir; resstdev)
</code></pre><p>Plot the results of binding isotherm calculations using the Beta mix, i.e., sum of all Beta fitting functions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inverseproblem/ANISPROU.jl/blob/17af90c1ac45d3341b79a786a8a91481521c4a13/src/plotstuff.jl#L392">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ANISPROU.saveresultVTK" href="#ANISPROU.saveresultVTK"><code>ANISPROU.saveresultVTK</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">saveresultVTK(protein, betpar, mpost)
</code></pre><p>Save the fitting surface in the VTK format for Paraview.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inverseproblem/ANISPROU.jl/blob/17af90c1ac45d3341b79a786a8a91481521c4a13/src/plotstuff.jl#L364">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ANISPROU.plotsurface3D" href="#ANISPROU.plotsurface3D"><code>ANISPROU.plotsurface3D</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">plotsurface3D(dobs, betamix; yscal, zscal, markersize, displayfig, ymin, ymax, savefig, outdir) -&gt; Makie.Figure
</code></pre><p>Plot the a 3D surface from the Beta mix together measured data as circles.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inverseproblem/ANISPROU.jl/blob/17af90c1ac45d3341b79a786a8a91481521c4a13/src/plot3d.jl#L3">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ANISPROU.plotareavsprotcon" href="#ANISPROU.plotareavsprotcon"><code>ANISPROU.plotareavsprotcon</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">plotareavsprotcon(proteinname, protcons, areas, linfitres, resstdev, outdir)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inverseproblem/ANISPROU.jl/blob/17af90c1ac45d3341b79a786a8a91481521c4a13/src/plotstuff.jl#L575">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ANISPROU.plotbetacomp1D" href="#ANISPROU.plotbetacomp1D"><code>ANISPROU.plotbetacomp1D</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">plotbetacomp1D(betamix, protcon)
</code></pre><p>Plot the components and the sum of Beta functions for a given protein concentration.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inverseproblem/ANISPROU.jl/blob/17af90c1ac45d3341b79a786a8a91481521c4a13/src/plotstuff.jl#L622">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ANISPROU.plotparamlines" href="#ANISPROU.plotparamlines"><code>ANISPROU.plotparamlines</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">plotparamlines(betamix)
plotparamlines(betamix, protcons)
plotparamlines(betamix, protcons, areas)
</code></pre><p>Plot the lines defined by the model parameters as a function of protein concentration.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inverseproblem/ANISPROU.jl/blob/17af90c1ac45d3341b79a786a8a91481521c4a13/src/plotstuff.jl#L202">source</a></section></article><h1 id="Other-non-exported-functions"><a class="docs-heading-anchor" href="#Other-non-exported-functions">Other non-exported functions</a><a id="Other-non-exported-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Other-non-exported-functions" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="ANISPROU.lssqregr" href="#ANISPROU.lssqregr"><code>ANISPROU.lssqregr</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">lssqregr(points::Matrix{var&quot;#s2&quot;} where var&quot;#s2&quot;&lt;:Real) -&gt; Tuple{Any, Any, Any}
</code></pre><p>Least squares linear regression in its simplest form.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inverseproblem/ANISPROU.jl/blob/17af90c1ac45d3341b79a786a8a91481521c4a13/src/utils.jl#L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ANISPROU.plotmodelines" href="#ANISPROU.plotmodelines"><code>ANISPROU.plotmodelines</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">plotmodelines(betpar, mcur, modname; firstidpar)
</code></pre><p>Plot the lines defined by the modes (default) or, optionally, other    parameters (see <code>firstidpar</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inverseproblem/ANISPROU.jl/blob/17af90c1ac45d3341b79a786a8a91481521c4a13/src/plotstuff.jl#L171">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ANISPROU.getmodparbeta" href="#ANISPROU.getmodparbeta"><code>ANISPROU.getmodparbeta</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getmodparbeta(betpar::ScaledBeta2DParams, mcur::Vector{var&quot;#s8&quot;} where var&quot;#s8&quot;&lt;:Real, ycur::Real) -&gt; Tuple{Any, Any, Any}
</code></pre><p>Get the parameters (mode, confidence, amplitude) of the Beta functions for given y (protein concentration).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inverseproblem/ANISPROU.jl/blob/17af90c1ac45d3341b79a786a8a91481521c4a13/src/invertITCdata2D.jl#L318-L322">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ANISPROU.forwmod2D" href="#ANISPROU.forwmod2D"><code>ANISPROU.forwmod2D</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">forwmod2D(betpar::ScaledBeta2DParams, xy::Matrix{var&quot;#s9&quot;} where var&quot;#s9&quot;&lt;:Real, mcur::Matrix{var&quot;#s8&quot;} where var&quot;#s8&quot;&lt;:Real) -&gt; Vector{Real}
</code></pre><p>Compute the forward response for given input parameters, i.e. the enthalpy   values (2D) for given Beta functions (2D) parameters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inverseproblem/ANISPROU.jl/blob/17af90c1ac45d3341b79a786a8a91481521c4a13/src/invertITCdata2D.jl#L264">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ANISPROU.readsingleexperiment" href="#ANISPROU.readsingleexperiment"><code>ANISPROU.readsingleexperiment</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">readsingleexperiment(singlefl::String) -&gt; Tuple{Any, Any, Any}
</code></pre><p>Real from ASCII file the observed/measured data from an experiment.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inverseproblem/ANISPROU.jl/blob/17af90c1ac45d3341b79a786a8a91481521c4a13/src/readITCdata.jl#L93">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ANISPROU.singlescaledbeta2D" href="#ANISPROU.singlescaledbeta2D"><code>ANISPROU.singlescaledbeta2D</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">singlescaledbeta2D(betpar::ScaledBeta2DParams, xy::Matrix{var&quot;#s8&quot;} where var&quot;#s8&quot;&lt;:Real, mcur::Vector{var&quot;#s6&quot;} where var&quot;#s6&quot;&lt;:Real) -&gt; Vector{Real}
</code></pre><p>2D-fied scaled Beta function for given x (SDS concentration) and y (protein concentration) values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inverseproblem/ANISPROU.jl/blob/17af90c1ac45d3341b79a786a8a91481521c4a13/src/invertITCdata2D.jl#L289-L293">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ANISPROU.scaledbeta" href="#ANISPROU.scaledbeta"><code>ANISPROU.scaledbeta</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">scaledbeta(mo::Real, kon::Real, a::Real, b::Real, amplscale::Real, x::Real) -&gt; Any
</code></pre><p>1D modified scaled Beta function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inverseproblem/ANISPROU.jl/blob/17af90c1ac45d3341b79a786a8a91481521c4a13/src/invertITCdata2D.jl#L373-L377">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ANISPROU.misfitfunctional" href="#ANISPROU.misfitfunctional"><code>ANISPROU.misfitfunctional</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">misfitfunctional(betpar::ScaledBeta2DParams, dobs::ITCObsData, invCd::Matrix{var&quot;#s11&quot;} where var&quot;#s11&quot;&lt;:Real, mcur::Matrix{var&quot;#s9&quot;} where var&quot;#s9&quot;&lt;:Real) -&gt; Any
</code></pre><p>Calculate the sum of the misfit for observed (measured) and calculated data and   the misfit of the integral of enthalpy (which should be zero) at zero protein   concentration.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inverseproblem/ANISPROU.jl/blob/17af90c1ac45d3341b79a786a8a91481521c4a13/src/invertITCdata2D.jl#L159">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ANISPROU.misfareaenth" href="#ANISPROU.misfareaenth"><code>ANISPROU.misfareaenth</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">misfareaenth(betpar::ScaledBeta2DParams, mcur2d::Matrix{var&quot;#s8&quot;} where var&quot;#s8&quot;&lt;:Real) -&gt; Any
</code></pre><p>Misfit functional for area of enthalpy (unscaled in this case): zero   area at protein concentration equal to zero.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inverseproblem/ANISPROU.jl/blob/17af90c1ac45d3341b79a786a8a91481521c4a13/src/invertITCdata2D.jl#L210">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ANISPROU.misfitbeta2D" href="#ANISPROU.misfitbeta2D"><code>ANISPROU.misfitbeta2D</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">misfitbeta2D(betpar::ScaledBeta2DParams, dobs::ITCObsData, invCd::Matrix{var&quot;#s11&quot;} where var&quot;#s11&quot;&lt;:Real, mcur::Matrix{var&quot;#s9&quot;} where var&quot;#s9&quot;&lt;:Real) -&gt; Any
</code></pre><p>Calculate misfit between observed/measured and calculated data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inverseproblem/ANISPROU.jl/blob/17af90c1ac45d3341b79a786a8a91481521c4a13/src/invertITCdata2D.jl#L188">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.5 on <span class="colophon-date" title="Monday 6 September 2021 09:31">Monday 6 September 2021</span>. Using Julia version 1.6.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
